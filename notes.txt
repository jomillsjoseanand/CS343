This assignment simulates a simple concession service

The following constants are used to configure the simulation, and are read from a text file:

SodaCost 2 # Manufacturer Suggested Retail Price (MSRP) per bottle
NumStudents 2 # number of students to create
MaxPurchases 8 # maximum number of bottles a student purchases
NumVendingMachines 3 # number of vending machines
MaxStockPerFlavour 5 # maximum number of bottles of each flavour in a vending machine
MaxShippedPerFlavour 3 # maximum number of bottles of each flavour generated by the bottling
# plant per production run
TimeBetweenShipments 3 # length of time between shipment pickup
GroupoffDelay 10 # length of time between initializing gift cards
ParentalDelay 5 # length of time between deposits of funds
NumCouriers 1 # maximum number of couriers in the pool

Comments in the file (from # to the end-of-line), as well as blank lines, 
are ignored. The constants may appear in any order. 
Any number of spaces/tabs may appear around a constant name, value or 
comment. Assume each constant appears in the configuration file, 
is syntactically correct, its value is within an appropriate range 
(i.e., no error checking is required), and only one constant is 
defined per line. 

Modify this sample file to obtain interesting results when testing.

Step 1:
struct ConfigParms {
    unsigned int sodaCost; // MSRP per bottle
    unsigned int numStudents; // number of students to create
    unsigned int maxPurchases; // maximum number of bottles a student purchases
    unsigned int numVendingMachines; // number of vending machines
    unsigned int maxStockPerFlavour; // maximum number of bottles of each flavour stocked
    unsigned int maxShippedPerFlavour; // number of bottles of each flavour in a shipment
    unsigned int timeBetweenShipments; // length of time between shipment pickup
    unsigned int groupoffDelay; // length of time between initializing gift cards
    unsigned int parentalDelay; // length of time between cash deposits
    unsigned int numCouriers; // number of couriers in the pool
};

void processConfigFile( const char *configFile, ConfigParms & cparms );
    - this method basically populates cparms 

Step 2:
_Task Student {
    void main();
    
    public:
        Student( Printer & prt, NameServer & nameServer, WATCardOffice & cardOffice, Groupoff & groupoff,
        unsigned int id, unsigned int maxPurchases );
};

Student context:
- A Student’s function is to periodically buy some of their favourite soda 
- Each student is passed an id in the range [0, NumStudents) for
identification.
- A student begins by selecting a random number of bottles to purchase [1, MaxPurchases]
- pick a random favourite flavour [0, 3] 
- creates a WATCard from the WATCardOffice and intialize balance with $5 
- creates a gift card from Groupoff with a value of $SodaCost
- obtains the location of a vending machine from the name server.
- A student terminates after purchasing their selected random number of bottles of their favourite flavour.

- Before each attempt to purchase a soda (including the first), a 
student yields a random number of times in the range [1, 10]. 
-  then wants to buy a soda but may need to wait for money to be 
transferred either from the WATCardOffice to their WATCard or from Groupoff 
to their gift card. 
    - Once money is available on either card, the student can attempt to 
    buy a bottle of soda from their current vending machine; 
        - if both cards have money, use the gift card first. 
        - Note, a giftcard future can only be used once, so it must be 
        reset after use to prevent any further usage.

- If a courier has lost a student’s WATCard during a transfer (see WATCardOffice::Courier),
the exception WATCardOffice::Lost is raised when the future value is accessed.
- In this case, the students watcard was lost the first time it must 
create a new WATCard from the WATCardOffice with a $5 balance, and re-attempt to purchase a soda without
yielding as a purchase has not occurred. 
-  a courier can lose a student’s WATCard during each transfer
for the new WATCard so this issue can occur repeatedly.

- Once money is available, a purchase begins with a student calling a vending machine to begin a transaction.
- If the vending machine debits the WATCard and delivers a bottle of soda, the student drinks it and attempts
another purchase. 
-  If the vending machine delivers a free bottle of soda (which does not count as a purchased
soda), there is a 50% chance the student watches an advertisement 
associated with it by yielding 4 times (not random) 
while drinking the free soda and then attempts another purchase.
- If the vending machine indicates
insufficient funds, a student transfers the current vending-machine soda-cost plus $5 to their WATCard via the
WATCard office and attempts another purchase.

- If the vending machine is out of the student’s favourite flavour,
the student must obtain a new vending machine from the name server and 
attempt another purchase.
- a student may perform a busy wait among vending machines until their 
specific soda appears from the bottling plant. 

*** NOTE: Watch out for the case of a student who only buys one soda using the gift card.


Step 3:
class WATCard {
        WATCard( const WATCard & ) = delete; // prevent copying
        WATCard( const WATCard && ) = delete;
        WATCard & operator=( const WATCard & ) = delete;
        WATCard & operator=( const WATCard && ) = delete;
    public:
        typedef Future_ISM<WATCard *> FWATCard; // future watcard pointer
        WATCard();
        void deposit( unsigned int amount );
        void withdraw( unsigned int amount );
        unsigned int getBalance();
};

- The WATCard manages the money associated with a card. 
- When a WATCard is created, it has a $0 balance.
- A courier calls deposit after a funds transfer
- A vending machine calls withdraw when a soda is purchased. 
- A student and a vending machine call getBalance to determine the balance.
- FWATCard is a future pointer to a student’s WATCard for synchronizing access 
to the WATCard between the student and the courier.

Step 4:
Task WATCardOffice {

    struct Job { // marshalled arguments and return future
        Args args; // call arguments (YOU DEFINE “Args”)
        WATCard::FWATCard result; // return future
        
        Job( Args args ) : args( args ) {}
    };

    _Task Courier { . . . }; // communicates with bank
        void main();
        
    public:
        _Exception Lost {}; // lost WATCard
        WATCardOffice( Printer & prt, Bank & bank, unsigned int numCouriers );
        
        WATCard::FWATCard create( unsigned int sid, unsigned int amount )
       
        __attribute__(( warn_unused_result ));
        WATCard::FWATCard transfer( unsigned int sid, unsigned int amount, WATCard *
        card )
        __attribute__(( warn_unused_result ));
        
        Job* requestWork() __attribute__(( warn_unused_result ));
};

- Create method eventually polulates future
- Job struct encapsualtes a request (request args + result stored in futrue which will eventuall be updated by create)
- requestWork fetches the next Job from the WATCardOffice.
- WatcardOffice produces withdraw requests to the which are delivered via courier


- The watcard office is an admin task 
-  transfer funds from their bank account to their WATCard to buy a soda.
- Initially, the WATCard office creates a fixed-sized courier pool with numCouriers
courier tasks to communicate with the bank. (Additional couriers may not be created after the WATCardOffice
begins.) 

- A student performs an asynchronous call to create to create a “real” WATCard with an initial balance.
- A future WATCard is returned and sufficient funds are subsequently obtained from the bank (see Parent task) via
a courier to satisfy the create request.
- A student performs an asynchronous call to transfer when their WATCard
indicates there is insufficient funds to buy a soda. 

- The WATCard office is empowered to transfer funds
from a student’s bank-account to its WATCard by sending a request 
through a courier to the bank. 
- Each courier task calls requestWork, blocks until a Job request 
is ready, and then receives the next Job request as the result
of the call. 
-  As soon as the request is satisfied (i.e., money is obtained from the bank), 
the courier updates the student’s WATCard. 
- There is a 1 in 6 chance, prng( 6 ) == 0, a courier loses a student’s WATCard 
after the update. 
- When the card is lost, the exception WATCardOffice::Lost is inserted into the future, 
rather than making the future available, and the current WATCard is deleted

Step 5: Bank
_Monitor Bank {
    public:
        Bank( unsigned int numStudents );
        void deposit( unsigned int id, unsigned int amount );
        void withdraw( unsigned int id, unsigned int amount );
};

- The Bank is a monitor, which behaves like a server
- Each student’s account initially starts with a balance of $0. 
- The parent calls deposit to give money to a specific student
- A courier calls withdraw to transfer money on behalf of the WATCard 
office for a specific student
- The courier waits until enough money has been deposited, 
which may require multiple deposits.

Step 6: Parent
_Task Parent {
    void main();
    
    public:
        Parent( Printer & prt, Bank & bank, unsigned int numStudents, unsigned int parentalDelay );
};

- Parent task periodically gives a random amount of money [$1, $3] to a random student [0, NumStudents),
in that order. 
- Before each gift is transferred (including the first), the parent yields for parentalDelay times (not
random).
- The parent must check for a call to its destructor to know when to 
terminate. 
- The parent must check for a call to its destructor to know when to terminate. Since it must not block
on this call, it is necessary to use a terminating _Else on the accept statement. Hence, the parent is performing
a yielding busy-wait on calls to its destructor.

Step 7: Groupoff

_Task Groupoff {
    void main();
    
    public:
        Groupoff( Printer & prt, unsigned int numStudents, unsigned int sodaCost, unsigned int groupoffDelay );
        WATCard::FWATCard giftCard( unsigned int id );
};

- Groupoff task begins by first accepting a call *from all students* to obtain a future gift-card
- After which groupoff periodically creates and puts a real WATCard 
with value $SodaCost into a random future gift-card.
- A future gift-card is assigned only once. 
- Before each future gift-card is assigned a real WATCard, groupoff
yields for groupoffDelay times (not random). 
- The groupoff loops until all the future gift-cards are assigned a real
WATCard or a call to its destructor occurs
- it must not block on the destructor call, it is necessary to use
a terminating _Else on the accept statement. This use of _Else is not busy waiting because there are a finite
number of students. Note, the lifetime of the gift cards is the lifetime of all students, not the lifetime of the
Groupoff thread.

GPT:
- Students request future gift-cards via giftCard(), and the Groupoff stores these requests.
- The Groupoff periodically assigns real WATCards to these requests, with a delay between assignments.
- The process continues until all gift-cards are assigned, or the Groupoff is explicitly terminated.
- The gift cards persist even after the Groupoff task terminates, ensuring they are available for the students' use.

Step 8: Vending machine
_Task VendingMachine {
    void main();

    public:
        _Exception Funds {}; // insufficient funds
        _Exception Stock {}; // flavour out of stock
        _Exception Free {}; // free, advertisement
        VendingMachine( Printer & prt, NameServer & nameServer, unsigned int id, unsigned int sodaCost );
        
        void buy( BottlingPlant::Flavours flavour, WATCard & card );
        unsigned int *
        inventory() __attribute__(( warn_unused_result ));
        void restocked();
        _Nomutex unsigned int cost() const;
        _Nomutex unsigned int getId() const;
};

- sell soda to students at some cost.
- Each vending machine is passed an id in the range [0, NumVendingMachines) for identification, and the MSRP price for a bottle of soda. 
- A new vending machine is empty (no stock) and begins by registering with the name server.
- student calls buy to obtain one of their favourite sodas. 
- vending machine first checks if the student has sufficient funds to purchase the soda a
- vending machine second checks if specified soda is available
- then the student’s WATCard is debited by the cost of a soda. -- note that we will have to check if the watcard exists
    - raise exceptions Funds or Stock, respectively. 
- Once a purchase is possible, there is a 1 in 5 chance the soda is free, which is indicated by raising exception Free

- Periodically, the truck comes by to restock the vending machines with new soda from the bottlig plant
- Restocking has two steps:
    - calls inventory to return a pointer to an array containing the amount of each kind of soda currently in the vending machine.
    - truck uses this information to transfer as much of its
stock as fits into the machine; for each kind of soda, no more than MaxStockPerFlavour per flavour can be added
to a machine.
    - After transferring new soda into the machine by directly modifying the array passed from inventory, the truck calls restocked to indicate the operation is complete
- The vending machine cannot accept buy calls during restocking
- the cost member returns the cost of purchasing a soda for this machine. 
- The getId member returns the identification number of the vending machine.

Step 9: Name server
_Task NameServer {
    void main();
    public:
        NameServer( Printer & prt, unsigned int numVendingMachines, unsigned int numStudents );
        void VMregister( VendingMachine *vendingmachine );
        VendingMachine *
        getMachine( unsigned int id ) __attribute__(( warn_unused_result ));
        VendingMachine **
        getMachineList() __attribute__(( warn_unused_result ));
};

- NameServer is a server task used to manage the vending-machine names.
- The name server is passed the number of vending machines, NumVendingMachines, and the number of students, NumStudents
- logically distributes students evenly across the vending machines using round-robin 
    - student id 0 is assigned to the first registered vending-machine, student id 1 is assigned to the second registered vendingmachine, etc.,
- Vending machines call VMregister to register themselves
so students can subsequently locate them. 
- getMachine to find a vending machine, and the name
server must cycle through the vending machines separately for each student starting from their initial position
via modulo incrementing to ensure a student has a chance to visit every machine. T
- e truck calls getMachineList To obtain an array of pointers to vending machines so it can visit each machine to deliver new soda. 
- vending machines are registered before accepting calls to other members.

Step 10: BottlingPlant
_Task BottlingPlant {
    void main();
    public:
    enum Flavours { . . ., NUM_OF_FLAVOURS }; // flavours of soda (YOU DEFINE)
        _Exception Shutdown {}; // shutdown plant
        
        BottlingPlant( Printer & prt, NameServer & nameServer, unsigned int numVendingMachines,
        
        unsigned int maxShippedPerFlavour, unsigned int maxStockPerFlavour,
        unsigned int timeBetweenShipments );
        
        void getShipment( unsigned int cargo[ ] );
};


- The bottling plant periodically produces random new quantities of each flavour of soda, [0, MaxShipped
PerFlavour] per flavour
- It begins by creating a truck
- performing a production run
    - To simulate a production run of soda, the bottling plant yields for TimeBetweenShipments times (not random)
- and waiting for the truck to pickup the production run. 
    - the shipment is copied into the cargo array passed by the truck.
- The truck then distributes these bottles to initialize the registered vending machines. 
- getShipment propagates the exception Shutdown if the bottling plant is closing
down, and no shipment is copied into the cargo array passed by the truck
- Use concurrent exceptions to raise Shutdown on the correct task.
- The bottling plant does not start another production run until the truck has picked
up the current run. 
- Define the public type Flavours to represent the different soda flavours available on page 1.

Step 11: truck 
_Task Truck {
    void main();
    public:
        Truck( Printer & prt, NameServer & nameServer, BottlingPlant & plant,
        unsigned int numVendingMachines, unsigned int maxStockPerFlavour );
};

- truck begins by obtaining the location of each vending machine from the
name server.
- Before each shipment from the bottling plant, the truck yields a random number of times [1, 10]
to get a coffee from Tom Hortons.
- AFTER shipped -- truck then calls BottlingPlant::getShipment to obtain a new shipment
of soda; any soda still on the truck is thrown away as it is past its due date.
- If the bottling plant is closing down, the truck terminates.
- To ensure fairness, the vending machines are restocked in cyclic order starting at
the vending machine after the last machine the truck restocked, until there is no more soda on the truck or the
truck has made a complete cycle of all the vending machines; so there is no guarantee each vending machine
is completely restocked or the entire complement of vending machines is restocked or all the soda on the truck
is used. 
- The truck can only restock up to MaxStockPerFlavour for each flavour in each vending machine (see
VendingMachine task). 
- there is a 1 in 100 chance of a flat tire,
which takes 10 yields (not random) to fix.

Step 12: Printer 
12. _Monitor / _Cormonitor Printer {
    
    public:
        enum Kind { Parent, Groupoff, WATCardOffice, NameServer, Truck, BottlingPlant, Student, Vending, Courier };
        Printer( unsigned int numStudents, unsigned int numVendingMachines, unsigned int numCouriers );
        void print( Kind kind, char state );
        void print( Kind kind, char state, unsigned int value1 );
        void print( Kind kind, char state, unsigned int value1, unsigned int value2 );
        void print( Kind kind, unsigned int lid, char state );
        void print( Kind kind, unsigned int lid, char state, unsigned int value1 );
        void print( Kind kind, unsigned int lid, char state, unsigned int value1, unsigned int value2 );
};

